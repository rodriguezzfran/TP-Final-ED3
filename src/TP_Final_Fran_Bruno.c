#include "LPC17xx.h"
#include "lpc17xx_dac.h"
#include "lpc17xx_adc.h"
#include "lpc17xx_gpio.h"
#include "lpc17xx_gpdma.h"
#include "lpc17xx_exti.h"
#include "lpc17xx_timer.h"
#include "lpc17xx_uart.h"
#include "lpc17xx_pinsel.h"

void conf_GPIO(void);
void conf_EXTI0(void);
void conf_EXTI1(void);
void conf_ADC(void);
void conf_DAC(void);
void conf_DMA(void);
void conf_UART(void);
void conf_Timer0(void);
void conf_Timer1(void);
void conf_Timer2(void);
void conf_Timer3(void);

void process_led_mode(uint8_t info);
void conf_PWMs_dc(uint8_t redVal,uint8_t greenVal,uint8_t blueVal);
void set_mode_normal(uint8_t redVal, uint8_t greenVal, uint8_t blueVal);
void set_mode_flash(void);
void set_mode_strobe(void);
void set_mode_fade(void);


void turn_on_PWMs(void);
void turn_off_PWMs(void);
void processReceivedData(void);
void delay(uint32_t times);


/*
 * SAMPLES_FREQ =  500[Hz] -> T between samples = 2[ms].
 * Then that should be the DAC timeout -> T_ticks = PCLK * T_out -> T_ticks = 25[MHz] * 2[ms] = 50000.
 */
#define ADC_FREQ 		200000
#define SAMPLES_FREQ 	500
#define CANT_SAMPLES 	(uint32_t)(5*SAMPLES_FREQ)//In a range of 5 seconds, 2500 data will be loaded with a rate of 500[Hz] (1 data in 2[ms]).
#define DAC_TOUT 		(uint32_t)(25000000/SAMPLES_FREQ)

#define REDLED_LPC		(1<<22)
#define GREENLED_LPC 	(1<<25)
#define BLUELED_LPC 	(1<<26)

#define REDLED_STRIP 	(1<<0)
#define GREENLED_STRIP 	(1<<1)
#define BLUELED_STRIP 	(1<<2)

#define UART_RX_BUFFER_SIZE 4

#define LED_MODE_NORMAL 	0
#define LED_MODE_FLASH 		1
#define LED_MODE_STROBE 	2
#define LED_MODE_FADE 		3

#define LED_SPEED_10 1
#define LED_SPEED_20 2
#define LED_SPEED_30 3
#define LED_SPEED_40 4
#define LED_SPEED_50 5
#define LED_SPEED_60 6
#define LED_SPEED_70 7
#define LED_SPEED_80 8
#define LED_SPEED_90 9

const uint8_t LED_Mode[] = {
	LED_MODE_NORMAL,
	LED_MODE_FLASH,
	LED_MODE_STROBE,
	LED_MODE_FADE
};
const uint8_t LED_Speed[] = {
	LED_SPEED_10,
	LED_SPEED_20,
	LED_SPEED_30,
	LED_SPEED_40,
	LED_SPEED_50,
	LED_SPEED_60,
	LED_SPEED_70,
	LED_SPEED_80,
	LED_SPEED_90
};

__IO uint32_t led_signal[CANT_SAMPLES] = {0}; //Signal to store the data converted by the ADC.
uint8_t uartRxBuffer[UART_RX_BUFFER_SIZE] = ""; //Buffer to store the data received by UART transmission.

uint8_t uartflag = 0; //Just a flag to resolve a bug generated by sending data from the application on the PC and receiving it via UART.
__IO uint8_t adc_converting = 0; //Flag to know when we are in the conversion period.
uint8_t mode = 0; //0: RGB lights controlled by UART from PC. 1: ADC signal recreation.
__IO uint16_t data_counter = 0; //Counter to let the ADC know when the last data was converted.
uint16_t secs_check = 0; //Counter for SysTick to count x seconds. In this case are 2.
uint8_t adc_preparing = 0; //Flag to let SysTick know when its have to count x seconds before work on ADC conversion.
uint8_t strobe_mode_slope = 1; //0: strobe mode getting brighter. 1: strobe mode becoming less bright.
uint8_t fade_mode_state = 0; 	//0: red led becomes less bright, green gets brighter, blue is off.
							 	//1: red is off, green becomes less bright, blue gets brighter.
							 	//2: red gets brighter, green is off, blue becomes less bright.

/*
 * Match values for PWMs duty cycles:
 * It will be seen later, but here is a spoiler. The prescale value for the timers that modulate PWMs is set to increase
 * TC every 100[us], and the PWMs period is 10[ms], then if we calculate the required match value to count 10[ms] (duty
 * cycle of 100%) we obtain: 10[ms]/100[us] = 100. Hence the required match value is equal to the required duty cycle.
 *
 * Here, three PWMs starts with a duty cycle of 50%.
 */
uint8_t current_red_pwm_duty = 50 - 1;
uint8_t current_green_pwm_duty = 50 - 1;
uint8_t current_blue_pwm_duty = 50 - 1;

//Led mode and led speed initialized as normal mode and speed of 10%
uint8_t led_mode = 0;
uint8_t led_speed = 0;

GPDMA_LLI_Type DMA_list;

int main(void) {
	//Clear Timers, EINT0/1, UART2, ADC and DMA pending interrupts
	NVIC->ICPR[0] |= 0b011110010000000001100100010000;

	conf_GPIO();

	conf_EXTI0();
	conf_EXTI1();
	conf_ADC();
	conf_DAC();
	conf_UART();
	conf_DMA();

	conf_Timer0();
	conf_Timer1();
	conf_Timer2();
	conf_Timer3();

	//Set P0.3 for ADC signal
	GPIO_SetValue(0, 0x8);

	GPIO_SetValue(3, GREENLED_LPC);

	NVIC_EnableIRQ(UART2_IRQn);
	NVIC_EnableIRQ(EINT0_IRQn);
	NVIC_EnableIRQ(EINT1_IRQn);
	turn_on_PWMs();

    while(1) {

    }

    return 0 ;
}


/*-----------------------------------------------------------------------------------------------------------------------------
* -----------------------------------------------------------------------------------------------------------------------------
* ---------------------------------------------Configuration-------------------------------------------------------------------
* -----------------------------------------------------------------------------------------------------------------------------
* -----------------------------------------------------------------------------------------------------------------------------
*/
void conf_GPIO(void){
	PINSEL_CFG_Type pinc;

	//P0.0 as GPIO for RED led's (PWM)
	pinc.Portnum = PINSEL_PORT_0;
	pinc.Pinnum = PINSEL_PIN_0;
	pinc.Pinmode = PINSEL_PINMODE_TRISTATE;
	pinc.Funcnum = PINSEL_FUNC_0;
	PINSEL_ConfigPin(&pinc);

	//P0.1 as GPIO for GREEN led's (PWM)
	pinc.Pinnum = PINSEL_PIN_1;
	PINSEL_ConfigPin(&pinc);

	//P0.2 as GPIO for BLUE led's (PWM)
	pinc.Pinnum = PINSEL_PIN_2;
	PINSEL_ConfigPin(&pinc);

	//P0.3 as GPIO for potentiometers VCC
	pinc.Pinnum = PINSEL_PIN_3;
	PINSEL_ConfigPin(&pinc);

	//Set P0.0, P0.1, P0.2, and P0.3 as output
	GPIO_SetDir(0,0b1111,1);


	//Also we configure the integrated led's for user alerts
	//P0.22 as GPIO for integrated red led
	pinc.Pinnum = PINSEL_PIN_22;
	PINSEL_ConfigPin(&pinc);

	//P3.25 as GPIO for integrated green led
	pinc.Portnum = PINSEL_PORT_3;
	pinc.Pinnum = PINSEL_PIN_25;
	PINSEL_ConfigPin(&pinc);

	//P3.26 as GPIO for integrated blue led
	pinc.Pinnum = PINSEL_PIN_26;
	PINSEL_ConfigPin(&pinc);

	//Set P0.22, P3.25 and P3.26 as output
	GPIO_SetDir(0, REDLED_LPC, 1);
	GPIO_SetDir(3, (GREENLED_LPC | BLUELED_LPC), 1);

	//Shut down led's
	LPC_GPIO0->FIOSET |= REDLED_LPC;
	LPC_GPIO3->FIOSET |= (GREENLED_LPC | BLUELED_LPC);
}

/*
 * Timer to modulate red led PWM
 */
void conf_Timer0(void){
	TIM_TIMERCFG_Type timc;
	timc.PrescaleOption=TIM_PRESCALE_TICKVAL;
	timc.PrescaleValue = 2500; //Tr = 100[us]

	TIM_MATCHCFG_Type matc;
	matc.MatchChannel = 0;
	matc.IntOnMatch = ENABLE;
	matc.ResetOnMatch = ENABLE;
	matc.StopOnMatch = DISABLE;
	matc.ExtMatchOutputType =TIM_EXTMATCH_NOTHING;
	matc.MatchValue = (uint32_t)(current_red_pwm_duty);

	TIM_Init(LPC_TIM0,TIM_TIMER_MODE,&timc);
	TIM_ConfigMatch(LPC_TIM0, &matc);

	NVIC_SetPriority(TIMER2_IRQn, 5);
}

/*
 * Timer to modulate green led PWM
 */
void conf_Timer1(void){
	TIM_TIMERCFG_Type timc;
	timc.PrescaleOption=TIM_PRESCALE_TICKVAL;
	timc.PrescaleValue = 2500; //Tr = 100[us]

	TIM_MATCHCFG_Type matc;
	matc.MatchChannel = 0;
	matc.IntOnMatch = ENABLE;
	matc.ResetOnMatch = ENABLE;
	matc.StopOnMatch = DISABLE;
	matc.ExtMatchOutputType =TIM_EXTMATCH_NOTHING;
	matc.MatchValue = (uint32_t)(current_green_pwm_duty);

	TIM_Init(LPC_TIM1,TIM_TIMER_MODE,&timc);
	TIM_ConfigMatch(LPC_TIM1, &matc);

	NVIC_SetPriority(TIMER2_IRQn, 5);
}

/*
 * Timer to modulate blue led PWM
 */
void conf_Timer2(void){
	TIM_TIMERCFG_Type timc;
	timc.PrescaleOption=TIM_PRESCALE_TICKVAL;
	timc.PrescaleValue = 2500; //Tr = 100[us]

	TIM_MATCHCFG_Type matc;
	matc.MatchChannel = 0;
	matc.IntOnMatch = ENABLE;
	matc.ResetOnMatch = ENABLE;
	matc.StopOnMatch = DISABLE;
	matc.ExtMatchOutputType =TIM_EXTMATCH_NOTHING;
	matc.MatchValue = (uint32_t)(current_blue_pwm_duty);

	TIM_Init(LPC_TIM2,TIM_TIMER_MODE,&timc);
	TIM_ConfigMatch(LPC_TIM2, &matc);

	NVIC_SetPriority(TIMER2_IRQn, 5);
}

/*
 * Timer for managing the behavior of different modes
 */
void conf_Timer3(void){
	NVIC_DisableIRQ(TIMER3_IRQn);

	TIM_TIMERCFG_Type timc;
	timc.PrescaleOption=TIM_PRESCALE_TICKVAL;
	timc.PrescaleValue = 2500; //Tr = 100[us]

	TIM_MATCHCFG_Type matc;
	matc.MatchChannel = 0;
	matc.IntOnMatch = ENABLE;
	matc.ResetOnMatch = ENABLE;
	matc.StopOnMatch = DISABLE;
	matc.ExtMatchOutputType =TIM_EXTMATCH_NOTHING;
	matc.MatchValue = (uint32_t)(20); //This match value doesn't matter for now because this timer will be used in other mode

	TIM_Init(LPC_TIM3,TIM_TIMER_MODE,&timc);
	TIM_ConfigMatch(LPC_TIM3, &matc);

	NVIC_SetPriority(TIMER2_IRQn, 5);
}

/*
 * External interrupt configuration to change between mode 0 and mode 1
 */
void conf_EXTI0(void){
	NVIC_DisableIRQ(EINT0_IRQn);
	//P2.10 as EINT0
	PINSEL_CFG_Type pinc;
	pinc.Portnum = PINSEL_PORT_2;
	pinc.Pinnum = PINSEL_PIN_10;
	pinc.Pinmode = PINSEL_PINMODE_PULLUP;
	pinc.Funcnum = PINSEL_FUNC_1;
	PINSEL_ConfigPin(&pinc);

	EXTI_SetMode(EXTI_EINT0,EXTI_MODE_EDGE_SENSITIVE);
	EXTI_SetPolarity(EXTI_EINT0,EXTI_POLARITY_LOW_ACTIVE_OR_FALLING_EDGE);
}

/*
 * External interrupt configuration for change mode between DAC output and ADC reading in mode 1
 */
void conf_EXTI1(void){
	NVIC_DisableIRQ(EINT1_IRQn);
	//P2.11 as EINT1
	PINSEL_CFG_Type pinc;
	pinc.Portnum = PINSEL_PORT_2;
	pinc.Pinnum = PINSEL_PIN_11;
	pinc.Pinmode = PINSEL_PINMODE_PULLUP;
	pinc.Funcnum = PINSEL_FUNC_1;
	PINSEL_ConfigPin(&pinc);

	EXTI_SetMode(EXTI_EINT1,EXTI_MODE_EDGE_SENSITIVE);
	EXTI_SetPolarity(EXTI_EINT1,EXTI_POLARITY_LOW_ACTIVE_OR_FALLING_EDGE);
}

void conf_ADC(void){
	NVIC_DisableIRQ(ADC_IRQn);
	//P0.23 as AD0.0
	PINSEL_CFG_Type pinc;
	pinc.Portnum = PINSEL_PORT_0;
	pinc.Pinnum = PINSEL_PIN_23;
	pinc.Pinmode = PINSEL_PINMODE_TRISTATE;
	pinc.Funcnum = PINSEL_FUNC_1;
	PINSEL_ConfigPin(&pinc);

	ADC_Init(LPC_ADC,ADC_FREQ);
	ADC_IntConfig(LPC_ADC,ADC_ADINTEN0,ENABLE);//Enable interrupt for DMA request
	//Since this is a previous configuration, the channel will be disabled until we need the ADC (exti0 handler).
	NVIC_SetPriority(ADC_IRQn, 5);
}

void conf_DAC(void){
	//P0.26 as AOUT
	PINSEL_CFG_Type pinc;
	pinc.Portnum = PINSEL_PORT_0;
	pinc.Pinnum = PINSEL_PIN_26;
	pinc.Pinmode = PINSEL_PINMODE_TRISTATE;
	pinc.Funcnum = PINSEL_FUNC_2;
	PINSEL_ConfigPin(&pinc);

	DAC_CONVERTER_CFG_Type dacc;
	dacc.CNT_ENA = SET;
	dacc.DMA_ENA = SET;


	DAC_ConfigDAConverterControl(LPC_DAC, &dacc);
	DAC_SetDMATimeOut(LPC_DAC, DAC_TOUT);
	DAC_Init(LPC_DAC);
	DAC_UpdateValue(LPC_DAC, 0);
}

void conf_DMA(void){
	NVIC_DisableIRQ(DMA_IRQn);

	DMA_list.SrcAddr = (uint32_t)led_signal;
	DMA_list.DstAddr = (uint32_t)(&LPC_DAC->DACR);
	DMA_list.NextLLI = (uint32_t)(&DMA_list);
	DMA_list.Control = (CANT_SAMPLES)	//Transfer size
				  |(2<<18)	//Source width = 32 bits
				  |(2<<21)	//Destination width = 32 bits
				  |(1<<26);	//Set SI
	DMA_list.Control &= ~(1<<27); //Clear DI

	GPDMA_Init();

	GPDMA_Channel_CFG_Type dmac;
	dmac.ChannelNum = 0;
	dmac.SrcMemAddr = (uint32_t)led_signal;
	dmac.DstMemAddr = 0;
	dmac.TransferSize = (CANT_SAMPLES);
	dmac.TransferWidth = 0;
	dmac.TransferType = GPDMA_TRANSFERTYPE_M2P;
	dmac.SrcConn = 0;
	dmac.DstConn = GPDMA_CONN_DAC;
	dmac.DMALLI = (uint32_t)(&DMA_list);
	GPDMA_Setup(&dmac);
}

void conf_UART(void) {
    // Configure pins for UART2
    PINSEL_CFG_Type PinCfg;
    PinCfg.Funcnum = 1;
    PinCfg.OpenDrain = 0;
    PinCfg.Pinmode = 0;
    PinCfg.Portnum = 0;
    PinCfg.Pinnum = 10;
    PINSEL_ConfigPin(&PinCfg);
    PinCfg.Pinnum = 11;
    PINSEL_ConfigPin(&PinCfg);

    UART_CFG_Type      UARTConfigStruct;
    UART_FIFO_CFG_Type UARTFIFOConfigStruct;

    //Default configuration
    UART_ConfigStructInit(&UARTConfigStruct);
    UARTConfigStruct.Baud_rate = 480600;

    //Initialize the peripheral
    UART_Init(LPC_UART2, &UARTConfigStruct);

    //Initialize FIFO
    UART_FIFOConfigStructInit(&UARTFIFOConfigStruct);
    UART_FIFOConfig(LPC_UART2, &UARTFIFOConfigStruct);

    //Enable interruption by the RX channel of the UART
    UART_IntConfig(LPC_UART2, UART_INTCFG_RBR, ENABLE);
    //Enable interruption due to the status of the UART line
    UART_IntConfig(LPC_UART2, UART_INTCFG_RLS, ENABLE);

    NVIC_SetPriority(UART2_IRQn, 3);
    return;
}





/*-----------------------------------------------------------------------------------------------------------------------------
* -----------------------------------------------------------------------------------------------------------------------------
* ---------------------------------------------Handlers------------------------------------------------------------------------
* -----------------------------------------------------------------------------------------------------------------------------
* -----------------------------------------------------------------------------------------------------------------------------
*/
void UART2_IRQHandler(void) {
	uartflag++;
	if(uartflag>1){
		uartflag = 0;
	}
	else{
		uint32_t intsrc, tmp, tmp1;
		//Determine the source of interruption
		intsrc = UART_GetIntId(LPC_UART2);
		tmp = intsrc & UART_IIR_INTID_MASK;

		//Evaluate Line Status
		if (tmp == UART_IIR_INTID_RLS){
			tmp1 = UART_GetLineStatus(LPC_UART2);
			tmp1 &= (UART_LSR_OE | UART_LSR_PE | UART_LSR_FE \
					| UART_LSR_BI | UART_LSR_RXFE);

			//Enter an infinite Loop if there is an error
			if (tmp1) {
				while(1){};
			}
		}

		//Receive Data Available or Character time-out
		if ((tmp == UART_IIR_INTID_RDA) || (tmp == UART_IIR_INTID_CTI)){
			UART_Receive(LPC_UART2, uartRxBuffer, UART_RX_BUFFER_SIZE, BLOCKING);
		}

		//Disable timer 3 to cleanly process data
		TIM_Cmd(LPC_TIM3, DISABLE);
		NVIC_DisableIRQ(TIMER3_IRQn);
		NVIC_ClearPendingIRQ(TIMER3_IRQn);
		processReceivedData();
	}
	return;
}

void EINT0_IRQHandler(void){
	if(mode == 0){
		//Disable UART
		UART_IntConfig(LPC_UART2, UART_INTCFG_RBR, DISABLE);
		UART_IntConfig(LPC_UART2, UART_INTCFG_RLS, DISABLE);

		//Shutdown PWM signals on GPIO pins
		turn_off_PWMs();
		NVIC_DisableIRQ(TIMER3_IRQn);
		TIM_Cmd(LPC_TIM3, DISABLE);

		//Enable SysTick
		if (SysTick_Config(SystemCoreClock/SAMPLES_FREQ)){	// SysTick 2ms
			while (1); // In case of error
		}
		NVIC_SetPriority(SysTick_IRQn, 5);

		adc_preparing = 1;
		mode = 1;
	}
	else{
		if(adc_converting || adc_preparing){
			//Alert to user and do nothing
			LPC_GPIO0->FIOCLR |= REDLED_LPC;
			delay(2000);
			LPC_GPIO0->FIOSET |= REDLED_LPC;
		}
		else{
			//Stop DMA transfer
			LPC_GPDMACH0->DMACCConfig &= ~(0x1);

			DAC_UpdateValue(LPC_DAC, 0);

			//Enable UART and PWM signals again
			UART_IntConfig(LPC_UART2, UART_INTCFG_RBR, ENABLE);
			UART_IntConfig(LPC_UART2, UART_INTCFG_RLS, ENABLE);

			NVIC_EnableIRQ(TIMER3_IRQn);
			TIM_Cmd(LPC_TIM3, ENABLE);
			turn_on_PWMs();

			mode=0;
		}
	}

	EXTI_ClearEXTIFlag(EXTI_EINT0);
	return;
}

void EINT1_IRQHandler(void){
	if(mode == 1){
		if(adc_converting || adc_preparing){
			//Alert to user and do nothing
			LPC_GPIO0->FIOCLR |= REDLED_LPC;
			delay(2000);
			LPC_GPIO0->FIOSET |= REDLED_LPC;
		}
		else{
			//Disable DMA Channel and stops transfer
			LPC_GPDMACH0->DMACCConfig &= ~(0x1);
			DAC_UpdateValue(LPC_DAC, 0);

			adc_preparing = 1;
		}
	}
	else{
		//Alert to user and do nothing
		LPC_GPIO3->FIOCLR |= BLUELED_LPC;
		delay(2000);
		LPC_GPIO3->FIOSET |= BLUELED_LPC;
	}


	EXTI_ClearEXTIFlag(EXTI_EINT1);
}

void ADC_IRQHandler(void){
	if(data_counter < CANT_SAMPLES){
		//Since the DAC should not deliver less than 0.7 V, we adapt the signal scaling it's values as follows.
		led_signal[data_counter] = ((((uint32_t)((((LPC_ADC->ADDR0) & (0x3FF<<6)) * 1000)/1185))+(160<<6)) & (0x3FF<<6));
		data_counter++;
	}
	else{
		data_counter = 0;
		NVIC_DisableIRQ(ADC_IRQn);
		GPIO_SetValue(3, GREENLED_LPC);
		adc_converting = 0;

		//Enable DMA Channel to start a new transfer
		LPC_GPDMACH0->DMACCConfig |= (0x1);
	}

	LPC_ADC->ADGDR &= LPC_ADC->ADGDR;//Clear flags
	LPC_ADC->ADDR0;
}

void SysTick_Handler(void){
	if(adc_preparing || adc_converting){
		if(adc_preparing){
			if(secs_check<(SAMPLES_FREQ*2)){//Count 2 seconds
				secs_check++;
			}
			else{
				//Start first conversion
				adc_preparing = 0;
				secs_check = 0;
				adc_converting = 1;
				NVIC_EnableIRQ(ADC_IRQn);
				ADC_ChannelCmd(LPC_ADC, ADC_CHANNEL_0, ENABLE);
				ADC_StartCmd(LPC_ADC, ADC_START_NOW);
				GPIO_ClearValue(3, GREENLED_LPC);//Tells the user that recording has started
			}
		}
		else{
			//Make a conversion
			ADC_StartCmd(LPC_ADC, ADC_START_NOW);
		}
	}

	SysTick->CTRL &= SysTick->CTRL;//Clear flag
}

void TIMER0_IRQHandler(void){
	//Modulation of a PWM for red led's
	LPC_TIM0->TCR |= 2;
	if(LPC_GPIO0->FIOPIN & (REDLED_STRIP)){
		if(current_red_pwm_duty < 99){
			LPC_GPIO0->FIOCLR |= REDLED_STRIP;
			LPC_TIM0->MR0 = 99 - current_red_pwm_duty - 1;
		}
	}
	else{
		if(current_red_pwm_duty > 0){
			LPC_GPIO0->FIOSET |= REDLED_STRIP;
			LPC_TIM0->MR0 = (uint32_t)(current_red_pwm_duty);
		}
	}
    LPC_TIM0->TCR &= ~(2);

	TIM_ClearIntPending(LPC_TIM0,TIM_MR0_INT);
}

void TIMER1_IRQHandler(void){
	////Modulation of a PWM for green led's
	 LPC_TIM1->TCR |= 2;
	if(LPC_GPIO0->FIOPIN & GREENLED_STRIP){
		if(current_green_pwm_duty < 99){
			LPC_GPIO0->FIOCLR |= GREENLED_STRIP;
			LPC_TIM1->MR0 = 99 - current_green_pwm_duty - 1;
		}
	}
	else{
		if(current_green_pwm_duty > 0){
			LPC_GPIO0->FIOSET |= GREENLED_STRIP;
			LPC_TIM1->MR0 = (uint32_t)(current_green_pwm_duty);
		}
	}
    LPC_TIM1->TCR &= ~(2);

	TIM_ClearIntPending(LPC_TIM1,TIM_MR0_INT);
}

void TIMER2_IRQHandler(void){
	//Modulation of a PWM for blue led's
	 LPC_TIM2->TCR |= 2;
	if(LPC_GPIO0->FIOPIN & (BLUELED_STRIP)){
		if(current_blue_pwm_duty < 99){
			LPC_GPIO0->FIOCLR |= BLUELED_STRIP;
			LPC_TIM2->MR0 = 99 - current_blue_pwm_duty - 1;
		}
	}
	else{
		if(current_blue_pwm_duty > 0){
			LPC_GPIO0->FIOSET |= BLUELED_STRIP;
			LPC_TIM2->MR0 = (uint32_t)(current_blue_pwm_duty);
		}
	}
    LPC_TIM2->TCR &= ~(2);

	TIM_ClearIntPending(LPC_TIM2,TIM_MR0_INT);
}

void TIMER3_IRQHandler(void){
	//Handles the behavior of different modes
	LPC_TIM3->TCR |= 2;
	switch(led_mode){
		case LED_MODE_FLASH:
			//Depending on which color is on, turn off this one and turn on the next one.
			if(LPC_GPIO0->FIOPIN & REDLED_STRIP){
				LPC_GPIO0->FIOCLR |= REDLED_STRIP;
				LPC_GPIO0->FIOSET |= GREENLED_STRIP;
			}
			else if(LPC_GPIO0->FIOPIN & GREENLED_STRIP){
				LPC_GPIO0->FIOCLR |= GREENLED_STRIP;
				LPC_GPIO0->FIOSET |= BLUELED_STRIP;
			}
			else if(LPC_GPIO0->FIOPIN & BLUELED_STRIP){
				LPC_GPIO0->FIOCLR |= BLUELED_STRIP;
				LPC_GPIO0->FIOSET |= REDLED_STRIP;
			}
			break;
		case LED_MODE_STROBE:
			/* Simulates a breath, if it is going down (strobe_mode_slope = 1) it decreases the
			 * duty cycles until they are brought to the minimum, if it is going up (strobe_mode_slope = 0)
			 * it increases the duty cycles until they are brought to the maximum.
			 */
			if(strobe_mode_slope){
				current_red_pwm_duty -= 2;
				current_green_pwm_duty -= 2;
				current_blue_pwm_duty -= 2;
				if(current_red_pwm_duty == 1 || current_green_pwm_duty == 1 || current_blue_pwm_duty== 1){
					current_red_pwm_duty -= 1;
					current_green_pwm_duty -= 1;
					current_blue_pwm_duty -= 1;
					strobe_mode_slope = 0;
				}
			}
			else{
				current_red_pwm_duty += 2;
				current_green_pwm_duty += 2;
				current_blue_pwm_duty += 2;
				if(current_red_pwm_duty == 98 || current_green_pwm_duty == 98 || current_blue_pwm_duty== 98){
					current_red_pwm_duty += 1;
					current_green_pwm_duty += 1;
					current_blue_pwm_duty += 1;
					strobe_mode_slope = 1;
				}
			}
			break;
		case LED_MODE_FADE:
			/*
			 * Generates the fade sequence, this has 3 "phases":
			 *   -First one: (fade_mode_state = 0) the red color decreases its intensity, the green
			 *    color increases it and the blue color remains off.
			 *   -Second one: (fade_mode_state = 1) the green color decreases its intensity, the blue
			 *    color increases it and the red color remains off.
			 *   -Third one: (fade_mode_state = 2) the blue color decreases its intensity, the red
			 *    color increases it and the green color remains off.
			 */
			if(fade_mode_state == 0){
				current_red_pwm_duty -= 2;
				current_green_pwm_duty += 2;
				if(current_red_pwm_duty == 1){
					current_red_pwm_duty -= 1;
					current_green_pwm_duty += 1;
					fade_mode_state = 1;
				}
			}
			else if(fade_mode_state == 1){
				current_green_pwm_duty -= 2;
				current_blue_pwm_duty += 2;
				if(current_green_pwm_duty == 1){
					current_green_pwm_duty -= 1;
					current_blue_pwm_duty += 1;
					fade_mode_state = 2;
				}
			}
			else if(fade_mode_state == 2){
				current_blue_pwm_duty -= 2;
				current_red_pwm_duty += 2;
				if(current_blue_pwm_duty == 1){
					current_blue_pwm_duty -= 1;
					current_red_pwm_duty += 1;
					fade_mode_state = 0;
				}
			}
			break;
	}

	LPC_TIM3->TCR &= ~(2);
	TIM_ClearIntPending(LPC_TIM3,TIM_MR0_INT);
	return;
}




/*-----------------------------------------------------------------------------------------------------------------------------
* -----------------------------------------------------------------------------------------------------------------------------
* ---------------------------------------------Functions-----------------------------------------------------------------------
* -----------------------------------------------------------------------------------------------------------------------------
* -----------------------------------------------------------------------------------------------------------------------------
*/

/*
 * This function separates the data received by UART, one of this data is the information about
 * the LED mode and the speed of the mode, this is sent to the process_led_mode() function and
 * based on the variables configured by said function, configures the corresponding mode calling
 * specific functions for each of these modes.
 *
 * Note: this function resets the timer counter of Timer 3 because there are modes that needs to
 * change the match value of this timer.
 */
void processReceivedData(void){
	LPC_TIM3->TCR |= (2);
	uint8_t info, blueVal, greenVal, redVal;
	blueVal = uartRxBuffer[0];
	greenVal = uartRxBuffer[1];
	redVal = uartRxBuffer[2];
	info = uartRxBuffer[3];

	process_led_mode(info);

	if(LPC_TIM0->TCR & 1 || LPC_TIM1->TCR & 1 || LPC_TIM2->TCR & 1){
		turn_off_PWMs();
	}

	switch(led_mode){
		case LED_MODE_NORMAL:
			set_mode_normal(redVal,greenVal,blueVal);
			break;
		case LED_MODE_FLASH:
			set_mode_flash();
			break;
		case LED_MODE_STROBE:
			set_mode_strobe();
			break;
		case LED_MODE_FADE:
			set_mode_fade();
			break;
	}
	LPC_TIM3->TCR &= ~(2);
}

/*
 * This function sets the normal mode by calling another function to configure the duty cycles
 * and turns on the PWM.
 */
void set_mode_normal(uint8_t redVal, uint8_t greenVal, uint8_t blueVal){
	conf_PWMs_dc(redVal,greenVal,blueVal);
	turn_on_PWMs();
}

/*
 * This function sets the flash mode by configuring the match value of timer 3 according to the
 * mode speed received in the data block by UART and starts the mode with the red color on so that
 * later in the timer 3 handler it alternates between the 3 colors.
 */
void set_mode_flash(void){

	LPC_TIM3->MR0 = (((10 - led_speed)*1000) - 1); //Increment duty cycles depending on led speed

	GPIO_SetValue(0, REDLED_STRIP);
	GPIO_ClearValue(0,(GREENLED_STRIP | BLUELED_STRIP));

	NVIC_EnableIRQ(TIMER3_IRQn);
	TIM_Cmd(LPC_TIM3,ENABLE);
}


/*
 * This function sets the strobe mode by configuring the match value of timer 3 according to the
 * mode speed received in the data block by UART and initializes the mode with the 3 colors turned
 * on at maximum so that later in the timer 3 handler the duty cycles go down and up simulating a breath.
 */
void set_mode_strobe(void){
	LPC_TIM3->MR0 = (((10 - led_speed)*100) - 1); //Increment duty cycles depending on led speed

	conf_PWMs_dc(255,255,255);

	strobe_mode_slope = 1;

	turn_on_PWMs();
	NVIC_EnableIRQ(TIMER3_IRQn);
	TIM_Cmd(LPC_TIM3, ENABLE);
}

/*
 * This function sets the fade mode by configuring the match value of timer 3 according to the mode
 * speed received in the data block via UART and initializes the mode with the red color at maximum
 * and the other two off so that later in the timer handler 3 the duty cycles are increased and decreased
 * respectively to generate the fade sequence.
 */
void set_mode_fade(void){
	LPC_TIM3->MR0 = (((10 - led_speed)*100) - 1); //Increment duty cycles depending on led speed

	conf_PWMs_dc(255,0,0);

	fade_mode_state = 0;

	turn_on_PWMs();
	NVIC_EnableIRQ(TIMER3_IRQn);
	TIM_Cmd(LPC_TIM3, ENABLE);
}

/*
 * This functions sets the led_mode and led_speed variables reading the last data in the block received by UART.
 */
void process_led_mode(uint8_t info){
	led_mode = LED_Mode[(info & 0xF)];
	led_speed = LED_Speed[((info & 0xF0)>>4)];
}

/*
 * This function configures a duty cycle proportional to the value received for each color.
 */
void conf_PWMs_dc(uint8_t redVal, uint8_t greenVal, uint8_t blueVal){
	current_red_pwm_duty = ((redVal*100/255) > 0) ? ((redVal*100/255) - 1) : 0;

	current_green_pwm_duty = ((greenVal*100/255) > 0) ? ((greenVal*100/255) - 1) : 0;

	current_blue_pwm_duty = ((blueVal*100/255) > 0) ? ((blueVal*100/255) - 1) : 0;
}

/*
 * This function turns on each PWM by enabling each timer and its interruptions.
 */
void turn_on_PWMs(void){
	NVIC_EnableIRQ(TIMER0_IRQn);
	NVIC_EnableIRQ(TIMER1_IRQn);
	NVIC_EnableIRQ(TIMER2_IRQn);

	TIM_Cmd(LPC_TIM0,ENABLE);
	TIM_Cmd(LPC_TIM1,ENABLE);
	TIM_Cmd(LPC_TIM2,ENABLE);
}

/*
 * This function turns off each PWM by disabling each timer and its interruptions, and
 * setting the respective pins to low.
 */
void turn_off_PWMs(void){
	NVIC_DisableIRQ(TIMER0_IRQn);
	NVIC_DisableIRQ(TIMER1_IRQn);
	NVIC_DisableIRQ(TIMER2_IRQn);

	NVIC_ClearPendingIRQ(TIMER0_IRQn);
	NVIC_ClearPendingIRQ(TIMER1_IRQn);
	NVIC_ClearPendingIRQ(TIMER2_IRQn);

	TIM_Cmd(LPC_TIM0,DISABLE);
	TIM_Cmd(LPC_TIM1,DISABLE);
	TIM_Cmd(LPC_TIM2,DISABLE);

	GPIO_ClearValue(0, (GREENLED_STRIP | BLUELED_STRIP | REDLED_STRIP));
}

void delay(uint32_t times) {
	for(uint32_t i=0; i<times; i++)
		for(uint32_t j=0; j<times; j++);
}
